# -*- coding: utf-8 -*-
"""110305075_AI_NetworkX.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KJ2GNtzwC7ZNwwQ39aq4Z0O7R11ELquB

# 2025/03/27 人工智慧方法與工具_TA03

TA：徐鈺蓉 \
mail：110306091@nccu.edu.tw \
Feel free to contact me if you have any questions😊

1. 拿到檔案請在 **檔案>在雲端硬碟中複製儲存副本** 將檔案複製至自己的雲端後再進行作業的修改
2. 完成quiz後上傳至moodl

## Get Data

請先到共用雲端硬碟將檔案`Pokemon.zip`，建立捷徑到自己的雲端硬碟中。

> 操作步驟
1. 點開雲端[連結](https://drive.google.com/file/d/1akt2lMsjBRKa1QxzoSEUgsLNIPOk1JLB/view?usp=sharing)
2. 點選右上角「新增雲端硬碟捷徑」
3. 點選「我的雲端硬碟」
4. 點選「新增捷徑」

完成以上流程會在你的雲端硬碟中建立一個檔案的捷徑，接著我們在colab中取得權限即可使用。

# 掛載雲端硬碟 & packages
"""

from google.colab import drive
drive.mount('/content/drive')

"""# 讀取資料 & 查看概況

https://www.kaggle.com/datasets/abcsds/pokemon

注意: 若有另外設定存放在雲端硬碟中的路徑，請記得本處路徑也須做更動。
"""

!unzip -qq ./drive/My\ Drive/Pokemon.zip

#!unzip -qq ./drive/My\ Drive/Colab_Notebooks/AI_Method_And_Tools/Pokemon.zip

"""若上述方式無法成功取得資料的同學可以使用此方式 \
1. 下載.zip 檔案
2. 解壓縮
3. 取消下方註解內容，手動上傳資料

使用此方法的同學須注意檔案名稱!!
"""

# from google.colab import files
# uploaded = files.upload()

"""---

"""

# 如果上述方法都不適用，請取消此段註解
# import pandas as pd
# sheet_url = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSQjTluTezvO3TB6rEcRF1EkjmXApDXJelBHNQzGUy3y-xR1PuqBS-vTyLAyMd3OJGhM6hoakBU9p-h/pub?output=csv"
# pokemon = pd.read_csv(sheet_url)

# 使用 pandas 讀取資料 pd.read_csv()
import pandas as pd
pokemon = pd.read_csv('Pokemon.csv')

# 查看前 5 筆資料
pokemon.head()

# 查看簡易的說明：每欄筆數/無缺失值數量/型態
pokemon.info()

# 查看 numerical data 的統計變量 df.describe()
pokemon.describe()

# 查看共有幾種神奇寶貝 .nunique()
print("Number of pokemon: " + str(pokemon['Name'].nunique())) #str():將型態轉換為字串

pokemon['Generation'] = pokemon.Generation.astype('category') #pokemon['Generation'] 數值 --> category

import numpy as np
# 針對 Type 2 補值，空值補 0，inplace = True 代表 修改後覆蓋原始檔案
pokemon['Type 2'].replace(np.nan, '0',inplace=True) #replace('1','2') -->用'2'取代'1'
# pokemon['Type 2'].fillna('0', inplace=True)

# 查看 Type 2 的各種類計數
pokemon['Type 2'].value_counts()

"""# Bar Plot

"""

# 載入相關套件
import numpy as np
import networkx as nx
import seaborn as sns
import matplotlib.pyplot as plt

# use plt to draw bar chart
top_25 = pokemon.sort_values(by='Total', ascending=False).head(25)

# 繪製長條圖
plt.figure(figsize=(10, 6))  # 設定圖的大小
plt.barh(top_25['Name'], top_25['Total'], color='skyblue',height=0.8)  # 水平長條圖 .barh(x1,x2) #垂直長條圖 .bar(x1,x2)
plt.xlabel('Total')  # 設定 x 軸標籤
plt.ylabel('Pokemon')  # 設定 y 軸標籤
plt.title('Top 25 Pokémon by Total')  # 設定圖表標題
plt.show()

# 長條圖: Total top 25 的神奇寶貝
plt.figure(figsize=(10, 6))    # 設定圖的大小
ax = sns.barplot(x='Total', y='Name', data=pokemon.sort_values(by='Total', ascending=False).head(25))   # 長條圖 barplot() x,y 欄位名稱
ax.set(xlabel='Total', ylabel='Pokemon')     # 設定 x 軸 / y 軸名稱
plt.show()

# 長條圖: 每種 Type 1 的 Defense 平均值
plt.figure(figsize=(10, 6))    # 設定圖的大小
ax = sns.barplot(x='Type 1', y='Defense',hue="Type 1", data=pokemon.groupby(['Type 1'], as_index=False)['Defense'].mean())   # 長條圖 barplot()
ax.set(xlabel='Type 1', ylabel='Defense')     # 設定 x 軸 / y 軸名稱
ax.set_xticklabels(ax.get_xticklabels(), rotation=90)

plt.axhline(pokemon['Defense'].mean(), color='red', linestyle='--') # 總體 Defense 平均線
plt.show()

# 長條圖: 每種 Type 1 的 Defense 平均值
# 利用 hue 增加種類
plt.figure(figsize=(10, 6))    # 設定圖的大小
ax = sns.barplot(x='Type 1', y='Defense',hue="Legendary", data=pokemon.groupby(['Type 1','Legendary'], as_index=False)['Defense'].mean())   # 長條圖 barplot()
ax.set(xlabel='Type 1', ylabel='Defense')     # 設定 x 軸 / y 軸名稱
ax.set_xticklabels(ax.get_xticklabels(), rotation=90)

#plt.axhline() 畫水平線 / plt.axvline() 畫垂直線
plt.axhline(pokemon[pokemon['Legendary']==True]['Defense'].mean(), color='red', linestyle='--') # 是Legendary的 Defense 平均線
plt.axhline(pokemon[pokemon['Legendary']==False]['Defense'].mean(), color='blue', linestyle=':') # 不是Legendary的 Defense 平均線

plt.show()

"""# Pie Plot"""

# 圓餅圖：legendary & non-legendary 分佈
explode = np.arange(len(pokemon['Legendary'].value_counts().unique())) * 0.1   # 突出的部分
colors = ['pink', 'yellow'] # 設定顏色

pokemon['Legendary'].value_counts().plot.pie(
    title="Percentage of Legendary & NoN-Legendary",
    figsize=(5, 3),
    startangle=90,  # 起始角度從上方90度開始
    explode=explode,
    colors=colors,
    autopct='%1.1f%%',   # 標示的格式 (百分比數值 保留一位小數)
    shadow=True) #增加陰影效果

plt.tight_layout()       # 調整佈局，避免標籤擠壓
plt.show()

# 圓餅圖：generation 分佈
explode = np.arange(len(pokemon['Generation'].value_counts().unique())) * 0.01   # 突出的部分
colors = ['red', 'blue', 'yellow', 'green', 'purple', 'orange']

pokemon['Generation'].value_counts().plot.pie(
    title="Percentage of Generation",
    figsize=(5, 3),
    startangle=90,  # 起始角度從上方90度開始
    explode=explode,
    colors=colors,
    autopct='%1.1f%%',   # 標示的格式
    shadow=True)

plt.tight_layout()       # 調整佈局
plt.show()

# 顏色依照generation排序
generation_counts = pokemon['Generation'].value_counts().sort_index()  # Sort by Generation number
# explode = np.arange(len(generation_counts)) * 0.01
colors = ['red', 'blue', 'yellow', 'green', 'purple', 'orange']
generation_counts.plot.pie(
    title="Percentage of Generation",
    figsize=(5, 3),
    startangle=90,
    explode=np.arange(len(generation_counts)) * 0.01,
    colors=colors,
    autopct='%1.1f%%',
    shadow=True
)
plt.tight_layout()       # 調整佈局
plt.show()

# 第 1 世代的神奇寶貝種類(Type 1)圓餅圖
type1 = pokemon[pokemon['Generation'] == 1]['Type 1']
explode = np.arange(len(type1.unique())) * 0.01   # 突出的部分

colors = ['red', 'blue', 'yellow', 'green', 'purple', 'orange', 'pink', 'brown']

type1.value_counts().plot.pie(
    figsize = (7,7),
    title = "Percentage of Different Type 1 of Pokemon",
    explode = explode,
    colors = colors,
    autopct = '%1.1f%%',   # 標示的格式
    shadow = True,
    startangle = 90       # 起始角度從上方90度開始
)

plt.tight_layout() # 調整佈局
plt.show()

"""小練習: \
請畫出神奇寶貝種類(Type 2)圓餅圖，並將空值改為"NoLabel" \

注意: 於最一開始的操作中已將空值用'0'取代

"""

# 小練習：神奇寶貝種類(Type 2)圓餅圖
# 空值(於先前操作已補0)請填入"NoLabel"
for i in range(len(pokemon)):
  if pokemon['Type 2'][i] == '0':
    pokemon['Type 2'][i] = 'NoLabel'

# 方法二: pokemon['Type 2'].replace('0', 'NoLabel',inplace=True)
type2 = pokemon[pokemon['Generation'] == 2]['Type 2']
explode = np.arange(len(type2.unique())) * 0.01   # 突出的部分

colors = ['red', 'blue', 'yellow', 'green', 'purple', 'orange', 'pink', 'brown']

# draw the plot
type2.value_counts().plot.pie(
    figsize = (7,7),
    title = "Percentage of Different Type 2 of Pokemon",
    explode = explode,
    colors = colors,
    autopct = '%1.1f%%',   # 標示的格式
    shadow = True,
    startangle = 90       # 起始角度從上方90度開始
)

plt.tight_layout() # 調整佈局
plt.show()

"""# Box Plot"""

# 建立一個 1*2的畫布
fig, ax = plt.subplots(1, 2, figsize=(12, 5))
# 查看第一代的神奇寶貝，各類別 (Type 1) 的 Total 的最大值/第三四分位數/中位數/第一四分位數
sns.boxplot(x='Total', y='Type 1', data=pokemon[pokemon['Generation'] == 1],hue="Type 1", ax=ax[0])
ax[0].set(ylabel='Pokemon type', xlabel='Total')  # 設定 x 軸 / y 軸名稱
ax[0].set_title('Overall Distribution for Generation 1', fontsize=14) # 設定標題

# 查看第一代的神奇寶貝，各類別 (Type 1) 的 Attack 的最大值/第三四分位數/中位數/第一四分位數
sns.boxplot(x='Attack', y='Type 1', data=pokemon[pokemon['Generation'] == 1],hue="Type 1", ax=ax[1])
ax[1].set(xlabel='Attack strength', ylabel='Type of pokemon') # 設定 x 軸 / y 軸名稱
ax[1].set_title('Attack Strength Distribution for Generation 1', fontsize=14)  # 設定標題

plt.tight_layout()
plt.show()

"""### 小練習
2 pies in 1
pie plot 1: Type1 result

pir plot2: 小練習的結果
"""

#Practice
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np

# 建立 1x2 畫布
fig, ax = plt.subplots(1, 2, figsize=(12, 5))

# 第一張圖 (Generation 1 的 Type 1 分布)
type_counts = pokemon[pokemon['Generation'] == 1]['Type 1'].value_counts()
explode = np.arange(len(type_counts)) * 0.01  # 讓每個區塊稍微突出

ax[0].pie(type_counts, labels=type_counts.index, explode=explode, autopct='%1.1f%%', startangle=90)
ax[0].set_title('Overall Distribution for Generation 1', fontsize=14)

# 第二張圖 (Generation 2 的 Type 2 分布)
type2_counts = pokemon[pokemon['Generation'] == 2]['Type 2'].value_counts()
explode2 = np.arange(len(type2_counts)) * 0.01  # 讓每個區塊稍微突出

# 動態生成顏色（若類別超過 8 個，防止顏色數不足）
colors = plt.cm.tab20.colors[:len(type2_counts)]

ax[1].pie(
    type2_counts,
    labels=type2_counts.index,
    explode=explode2,
    colors=colors,
    autopct='%1.1f%%',
    shadow=True,
    startangle=90
)
ax[1].set_title('Overall Distribution for Generation 2', fontsize=14)

plt.show()

"""NetworkX data analysis
===

基本介紹
"""

# import networkx as nx
# 建立空 graph 不包含節點與邊
G1 = nx.Graph()          # 無向圖
G2 = nx.DiGraph()        # 有向圖

# Node
# 每個節點都有唯一的標籤:label，可以用整數或字元表示，另外還可以有額外自訂屬性

G1.add_node(1)  # 新增節點 1，無屬性

G1.add_node(2, name='n1', weight=1.0, date='May-16')    # 新增節點 2，屬性：name, weight, date

G1.add_nodes_from([3, 4, 5])      # 同時新增多個節點

G1.add_nodes_from([(6, {'type': 'int'}), ('7', {'type': 'str'})]) # 同時新增多個節點，並設定各自屬性 add_nodes_from([(node, {attribute:v alue}), (...)])

G1.remove_node('7')  # 刪除節點 '7'

# G1.remove_nodes_from([node1, node2, ...])  # 刪除多個節點

G1.nodes.data() # get information about all nodes in a graph

nx.draw(G1, with_labels=True)

# Edge
# 節點與節點之間的連接

G1.add_edge(1, 2)                # 新增頂點 1 和頂點 2 之間的邊，如點不存在，會自動新增

G1.add_edge(3, 4, weight=2.7)    # 新增頂點 3 和頂點 4 之間的邊，定義其 weight

G1.add_edges_from([(5, 6), (6 , 2)])  # 同時新增多個邊

G1.add_edges_from([(2, 3, {'weight': 10})])  # 同時新增多個邊，並設定各自屬性 add_nodes_from([(node1, node2, {attribute:v alue}), (...)])

# G1.remove_edge(0, 1)  # 從圖中刪除邊 0-1
# G1.remove_edges_from([(2,3),(1,5),(6,7)])  # 刪除多條邊

# 畫出來看看 nx.draw()
nx.draw(G1, with_labels=True)

# 計算平均最短路徑長度
nx.average_shortest_path_length(G1)

shortest_path_length = nx.shortest_path_length(G1, source=1, target=4, weight="weight")
print(f"Shortest path length (weighted) from 1 to 4: {shortest_path_length}")

"""查看圖的基本資訊"""

print("節點數量:", G1.number_of_nodes())
print("邊數量:", G1.number_of_edges())
print("節點列表:", G1.nodes())
print("邊列表:", G1.edges())
print("節點內容:", G1.nodes.data())
print("邊內容:", G1.edges.data())

"""##pokemon 分析"""

# 以 Type 1 為中心點，連接著屬於 Type 1 的神奇寶貝們
# from_pandas_edgelist(df,column name1, column name 2, create_using = None) 從 dataframe 建立 graph (undirected graph)
# create_using = None --> undirected graph, create_using = nx.DiGraph() --> directed graph
g = nx.from_pandas_edgelist(pokemon, source='Name', target='Type 1') #edges created between 'Name' and its corresponding 'Type 1'
plt.figure(figsize=(20, 20))
position = nx.spring_layout(g, k=0.15) # k用於調節節點之間的位置
nx.draw_networkx(g, position, node_size=25, node_color='blue')
plt.show()

# 以 Type 1 為中心點，連接著屬於 Type 1 的「第一代」神奇寶貝們
g = nx.from_pandas_edgelist(pokemon[pokemon['Generation'] == 1], source='Name', target='Type 1')
plt.figure(figsize=(20, 20))
pos = nx.spring_layout(g, k=0.15)
nx.draw_networkx(g, pos, node_size=800, node_color='pink', font_size=15)
plt.show()

"""## t-SNE 降維"""

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE
from sklearn.preprocessing import LabelEncoder


attributes = ['HP', 'Attack', 'Defense', 'Sp. Atk', 'Sp. Def', 'Speed'] # the columns that will be used for dimension reduction
X = pokemon[attributes]

# 決定要降成幾維
tsne = TSNE(n_components=2, random_state=42)
X_tsne = tsne.fit_transform(X)

plt.figure(figsize=(10, 8)) # 畫布大小
total_values = pokemon['Total'] # 選擇顏色的數值
color_map = plt.cm.viridis  # 選擇colormap
plt.scatter(X_tsne[:, 0], X_tsne[:, 1], c=total_values, cmap=color_map) #畫顏色

plt.title('t-SNE Visualization of Pokemon Attributes')
plt.xlabel('t-SNE Component 1')
plt.ylabel('t-SNE Component 2')
plt.colorbar(label='Total')  # Adding colorbar
plt.grid(True)
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE
from sklearn.preprocessing import LabelEncoder

attributes = ['HP', 'Attack', 'Defense', 'Sp. Atk', 'Sp. Def', 'Speed']
X = pokemon[attributes]

# 決定要降成幾維
tsne = TSNE(n_components=2, random_state=42)
X_tsne = tsne.fit_transform(X)

plt.figure(figsize=(10, 8)) #畫布大小
types = pokemon['Legendary'] # 選擇顏色的依據
unique_types = types.unique() # 取得唯一的類別(True/False)
colors = plt.cm.tab10.colors[:len(unique_types)] #選擇顏色

for i, type_name in enumerate(unique_types): #根據種類畫相對的顏色
    plt.scatter(X_tsne[types == type_name, 0], X_tsne[types == type_name, 1], label=type_name, color=colors[i])
    # types == type_name 會回傳布林陣列，標記符合條件的資料

plt.title('t-SNE Visualization of Pokemon Attributes')
plt.xlabel('t-SNE Component 1')
plt.ylabel('t-SNE Component 2')
plt.legend(title='Type 1', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.grid(True)
plt.show()

"""# Quiz

### Quiz1:

請用barplot畫出不同世代(Generation)以及是否為Legendary的平均HP長條圖，並標出是否為Legandary的HP總平均線
"""

################### Try it ########################

# 長條圖: 每種 Type 1 的 Defense 平均值
# 利用 hue 增加種類

plt.figure(figsize=(10, 6))    # 設定圖的大小
ax = sns.barplot(x='Generation', y='HP',hue="Legendary", data=pokemon.groupby(['Generation','Legendary'], as_index=False)['HP'].mean())   # 長條圖 barplot()
ax.set(xlabel='Generation', ylabel='Average HP')     # 設定 x 軸 / y 軸名稱
ax.set_xticklabels(ax.get_xticklabels(), rotation=90)

#plt.axhline() 畫水平線 / plt.axvline() 畫垂直線
plt.axhline(pokemon[pokemon['Legendary']==True]['HP'].mean(), color='red', linestyle='--') # 是Legendary的 Defense 平均線
plt.axhline(pokemon[pokemon['Legendary']==False]['HP'].mean(), color='blue', linestyle=':') # 不是Legendary的 Defense 平均線

plt.show()

"""### Quiz2:
 完成以下 graph 設定，並列印圖型

![image](https://i.imgur.com/7Aag11q.png)

Hint:

(1) 請建立以 G 為變數名稱的 graph --> Digraph()

(2) 設定：

*   節點 label：Alice, Bob, Store, Manufacturer
*   節點屬性 role：Person & Retailer & Supplier
*   邊屬性 relation：Friend & Customer & Belong to

(3) 請注意邊的箭頭方向，如果是雙向箭頭的邊要有兩次

"""

# ===== Try it =======
# type here
G = nx.DiGraph()

G.add_node('Alice', role='Person')
G.add_node('Bob', role='Person')
G.add_node('Store', role='Retailer')
G.add_node('Manufacturer', role='Supplier')

G.add_edge('Alice', 'Bob', relation='Friend')
G.add_edge('Bob', 'Alice', relation='Friend')
G.add_edge('Store', 'Manufacturer', relation='Belong to')
G.add_edge('Bob', 'Store', relation='Customer')
G.add_edge('Alice', 'Store', relation='Customer')
# ===== 以下請勿更動 =====
node_labels = {node[0]: f"{node[0]}\n{node[1]['role']}" for node in G.nodes.data()}
edge_labels = {(u, v): G[u][v]['relation'] for u, v in G.edges()}

pos = nx.spring_layout(G, seed=0)
nx.draw(G, pos, node_size=1000, node_color='lightblue')
nx.draw_networkx_labels(G, pos, labels=node_labels, font_size=10, font_weight='bold')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)
plt.show()

"""###Quiz3:

利用 Pokemon.csv 完成以下的 graph (不要自己key!)
![](https://i.imgur.com/HQdXUqd.png)
以 Generation 為六個中心，連接各自 Attack 最高前三名的神奇寶貝

Hint: groupby(), sort_values()...

"""

# 每個 generation 前三名的值，僅供參考

# ===== Try it =======

## prepare the dataframe
# 選取每個世代 Attack 值最高的前三隻寶可夢
sorted_pokemon = pokemon.sort_values(by=['Generation', 'Attack'], ascending=[True, False])
top_attack_pokemon = sorted_pokemon.groupby("Generation").head(3)

# 建立邊 (Edges) 資料
edges = []
for gen in top_attack_pokemon['Generation'].unique():
    top3 = top_attack_pokemon[top_attack_pokemon['Generation'] == gen]['Name'].tolist()
    for pokemon_name in top3:
        edges.append((f'{gen}', pokemon_name))  # 連接前三名寶可夢

# 建立 NetworkX 圖形
g = nx.Graph()
g.add_edges_from(edges)  # 從 Edges 清單建立圖形

# ===== 以下請勿更動 =====
plt.figure(figsize=(15, 8))
pos = nx.circular_layout(g)  # 以圓形調節節點之間的位置
nx.draw_networkx(g, pos, node_size=500, node_color='pink')
plt.show()

