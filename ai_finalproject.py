# -*- coding: utf-8 -*-
"""AI_finalProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HOtQfy-1pfYUiPlRxOMsZCujcSxSN88g
"""

from google.colab import drive
drive.mount('/content/drive')

import pickle
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import pearsonr
import scipy.stats as stats
import statsmodels.api as sm
from statsmodels.formula.api import ols
import plotly.express as px

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBRegressor
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import LabelEncoder

from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, roc_auc_score, classification_report
from scipy.stats import pearsonr
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/supply_chain_data.csv')

df.head()

print(len(df))   #100筆資料
df.columns

# 確認是否有缺失值
df.isnull().sum()   #no missing value

"""## 簡單EDA

### Product analysis
"""

color_map_prod = {
    'cosmetics': '#FBFFB9',
    'skincare': '#FDD692',
    'haircare': '#EC7357'
}
# Product type distribution
plt.figure(figsize=(10, 6))
product_counts = df['Product type'].value_counts()
sns.barplot(x = product_counts.index, y = product_counts.values, palette=color_map_prod)
plt.title('Product Type Distribution')
plt.xlabel('Product Type')
plt.ylabel('Count')
plt.show()

# Price distribution by product type
plt.figure(figsize=(12, 6))
sns.boxplot(x='Product type', y='Price', data=df, palette=color_map_prod)
plt.title('Price Distribution by Product Type')
plt.show()

# Revenue vs Products Sold
fig = px.scatter(df, x='Number of products sold', y='Revenue generated',
                 color='Product type', size='Price',
                 title='Revenue vs Products Sold by Product Type')
fig.show()

#defect rate 和product type之間的關係
plt.figure(figsize=(12, 6))
sns.boxplot(x='Product type', y='Defect rates', data=df, palette=color_map_prod)
plt.title('Defect Rate Distribution by Product Type')
plt.xlabel('Product Type')
plt.ylabel('Defect Rate')
plt.xticks(rotation=45)
plt.show()

# 自訂的顏色對照表
color_map_trans = {
    'Air': '#FBFFB9',
    'Sea': '#ffc952',
    'Rail': '#47b8e0',
    'Road': '#274c5e'
}

# 分組
grouped = df.groupby('Product type')

# 子圖排列設定
n_types = len(grouped)
n_cols = 3
n_rows = (n_types + n_cols - 1) // n_cols
fig, axes = plt.subplots(n_rows, n_cols, figsize=(n_cols * 5, n_rows * 5))
axes = axes.flatten()

# 繪圖
for i, (product_type, group) in enumerate(grouped):
    mode_counts = group['Transportation modes'].value_counts()
    modes = mode_counts.index
    sizes = mode_counts.values
    colors = [color_map_trans.get(mode, '#bbbbbb') for mode in modes]  # 若遇未知模式則用灰色

    axes[i].pie(
        sizes,
        labels=modes,
        autopct='%1.1f%%',
        startangle=90,
        colors=colors
    )
    axes[i].set_title(f'{product_type} - Transportation Modes')

# 移除多餘子圖
for j in range(i + 1, len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""### Location analysis"""

# Location-wise product distribution
location_product = df.groupby(['Location', 'Product type']).size().unstack()
location_product.plot(kind='bar', stacked=True, figsize=(12, 6))
plt.title('Product Distribution by Location')
plt.ylabel('Count')
plt.show()

# Supplier performance metrics
supplier_metrics = df.groupby('Supplier name').agg({
    'Lead times': 'mean',
    'Manufacturing costs': 'mean',
    'Defect rates': 'mean'
}).reset_index()

fig = px.bar(supplier_metrics, x='Supplier name', y=['Lead times', 'Manufacturing costs', 'Defect rates'],
             title='Supplier Performance Metrics', barmode='group')
fig.show()

# 繪製 boxplot
plt.figure(figsize=(16, 8))
sns.boxplot(
    data=df,
    x='Location',
    y='Manufacturing costs',
    hue='Product type'
)
plt.title('Manufacturing Costs by Product Type and Location')
plt.xlabel('Location')
plt.ylabel('Manufacturing Costs')
plt.xticks(rotation=45)
plt.legend(title='Location', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

plt.figure(figsize=(16, 8))
sns.boxplot(
    data=df,
    x='Location',
    y='Shipping costs',
    hue='Product type'
)
plt.title('Shipping costs Product Type and Location')
plt.xlabel('Location')
plt.ylabel('Shipping Costs')
plt.xticks(rotation=45)
plt.legend(title='Location', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

plt.figure(figsize=(16, 8))
sns.boxplot(
    data=df,
    x='Location',
    y='Costs',
    hue='Product type'
)
plt.title('Costs Product Type and Location')
plt.xlabel('Location')
plt.ylabel('Costs')
plt.xticks(rotation=45)
plt.legend(title='Location', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

plt.figure(figsize=(16, 8))
sns.boxplot(
    data=df,
    x='Location',
    y='Lead times',
    hue='Product type'
)
plt.title('Lead times by Product Type and Location')
plt.xlabel('Location')
plt.ylabel('Manufacturing Costs')
plt.xticks(rotation=45)
plt.legend(title='Location', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""### Transportation and Logistics analysis"""

# Transportation mode analysis
plt.figure(figsize=(10, 6))
sns.countplot(x='Transportation modes', data=df, palette="Blues")
plt.title('Transportation Mode Distribution')
plt.show()

# Shipping costs by carrier
plt.figure(figsize=(12, 6))
sns.boxplot(x='Shipping carriers', y='Shipping costs', hue='Transportation modes', data=df)
plt.title('Shipping Costs by Carrier and Transportation Mode')
plt.show()

# Lead time vs Manufacturing costs
fig = px.scatter(df, x='Lead times', y='Manufacturing costs',
                 color='Product type', size='Production volumes',
                 title='Lead Time vs Manufacturing Costs')
fig.show()

# 設定風格
sns.set(style="whitegrid")

# 圖一：物流方式 vs. Lead time
plt.figure(figsize=(10, 6))
sns.boxplot(x='Transportation modes', y='Lead time', data=df, palette=color_map_trans)
plt.title('Lead Time by Transportation Mode')
plt.ylabel('Lead Time')
plt.xlabel('Transportation Mode')
plt.show()

# 圖二：物流方式 vs. Defect rate
plt.figure(figsize=(10, 6))
sns.boxplot(x='Transportation modes', y='Defect rates', data=df, palette=color_map_trans)
plt.title('Defect Rate by Transportation Mode')
plt.ylabel('Defect Rate')
plt.xlabel('Transportation Mode')
plt.show()

"""## 1.不同地區的物流效率有顯著差異嗎？

"""

# 畫出不同地區的運送時間分佈（可視化用）
plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x='Location', y='Shipping times')
plt.title('Shipping time in different regions') #不同地區的運送時間分佈
plt.xticks(rotation=45)
plt.show()

# 分組取出每個地區的運送時間
groups = [group['Shipping times'].values for name, group in df.groupby('Location')]

# 做單因子變異數分析（ANOVA）
f_stat, p_value = stats.f_oneway(*groups)

# 輸出結果
print(f"ANOVA F值: {f_stat:.2f}")
print(f"p-value: {p_value:.4f}")

if p_value < 0.05:
    print("結論：不同地區之間的物流效率（以運送時間衡量）存在顯著差異。")
else:
    print("結論：不同地區之間的物流效率差異不顯著。")

"""## 2.不同產品類別在物流表現上是否存在差異？

"""

# 可視化：不同產品類別的運送時間分佈
plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x=df['Product type'], y=df['Shipping times'])
plt.xticks(rotation=45)
plt.title('Shipping times for different products')   #不同產品類別的運送時間比較
plt.show()

# 分組取出每個產品類別的運送時間
groups = [group['Shipping times'].values for name, group in df.groupby('Product type')]

# 單因子 ANOVA 分析
f_stat, p_value = stats.f_oneway(*groups)

# 輸出結果
print(f"ANOVA F值: {f_stat:.2f}")
print(f"p-value: {p_value:.4f}")

if p_value < 0.05:
    print("結論：不同產品類別之間的物流表現存在顯著差異。")
else:
    print("結論：不同產品類別之間的物流表現差異不顯著。")

"""## 3.產品類別與地區之間是否存在交互影響？

"""

# 建立兩因子含交互作用的 ANOVA 模型
model = ols('Q("Revenue generated") ~ C(Q("Product type")) * C(Location)', data=df).fit()
anova_table = sm.stats.anova_lm(model, typ=2)

print(anova_table)

"""結論：產品類別與地區之間的交互影響並不顯著

## 4.是否有物流瓶頸（如高缺陷率或高成本）集中於特定的地區－產品組合？
"""

# 計算每個地區-產品組合的平均缺陷率與物流成本
grouped = df.groupby(['Product type', 'Location']).agg({
    'Defect rates': 'mean',
    'Costs': 'mean'
}).reset_index()

# 建立 pivot table 供 heatmap 使用
pivot_defect = grouped.pivot(index='Product type', columns='Location', values='Defect rates')
pivot_costs = grouped.pivot(index='Product type', columns='Location', values='Costs')

# 畫出缺陷率熱圖
plt.figure(figsize=(10, 6))
sns.heatmap(pivot_defect, annot=True, cmap='Reds', fmt=".2f")
plt.title('Avg Defect rate-Product Type × Location')
plt.show()

# 畫出成本熱圖
plt.figure(figsize=(10, 6))
sns.heatmap(pivot_costs, annot=True, cmap='Blues', fmt=".2f")
plt.title('Avg Cost-Product Type × Location')
plt.show()

"""### 4-2.價格高低與defect rates是否有關"""

# 1. 分三分位數等分價格
df['Price_group'] = pd.qcut(df['Price'], q=3, labels=['Low', 'Medium', 'High'])

# 2. 繪製瑕疵率的 boxplot
plt.figure(figsize=(8, 6))
sns.boxplot(x='Price_group', y='Defect rates', data=df, palette='Set2')
plt.title('Defect Rates by Price Group (Low / Medium / High)')
plt.xlabel('Price Group')
plt.ylabel('Defect Rate')
plt.tight_layout()
plt.show()

corr, p_value = pearsonr(df['Price'], df['Defect rates'])
print(f"Correlation: {corr}, P-value: {p_value}")

"""結論：價格高低與defect rate關係並不顯著

### 4-3. Product type 與 Location 是否顯著影響瑕疵率
見3.

###4-4. 鎖定異常值：追查異常高瑕疵率的原因
"""

# Step 1: 篩選出 Chennai + haircare 資料
subset = df[(df['Product type'] == 'haircare') & (df['Location'] == 'Chennai')]

print(f"Chennai + haircare 總筆數: {len(subset)}")
display(subset.describe(include='all'))

# Step 2: 檢視相關欄位的分佈
cols_to_plot = ['Defect rates', 'Manufacturing lead time', 'Manufacturing costs',
                'Inspection results', 'Price', 'Revenue generated']

for col in cols_to_plot:
    plt.figure(figsize=(6, 4))
    sns.histplot(subset[col], kde=True, bins=10)
    plt.title(f'{col} distribution - haircare@Chennai')
    plt.show()

# Step 3: 看看是否某些供應商導致品質下降
plt.figure(figsize=(12, 6))
sns.boxplot(data=subset, x='Supplier name', y='Defect rates', palette='Set2')

# 計算各供應商平均瑕疵率
mean_rates = subset.groupby('Supplier name')['Defect rates'].mean()

# 在每個 box 上方標示平均值
for i, supplier in enumerate(mean_rates.index):
    mean_val = mean_rates[supplier]
    plt.text(i, mean_val + 0.05, f"{mean_val:.2f}",
             ha='center', va='bottom', fontsize=10, color='black')

plt.title('Chennai haircare - defect rate from different suppliers: Boxplot + mean')
plt.ylabel('Defect Rate')
plt.xlabel('Supplier Name')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Step 4: 與其他地區 haircare 做比較
others = df[(df['Product type'] == 'haircare') & (df['Location'] != 'Chennai')]

compare_cols = ['Defect rates', 'Manufacturing lead time', 'Manufacturing costs', 'Price']

for col in compare_cols:
    plt.figure(figsize=(8, 4))
    sns.boxplot(data=df[df['Product type'] == 'haircare'], x='Location', y=col)
    plt.title(f'{col} - haircare at different location')
    plt.show()

print(subset.to_string())

# Step 1: 篩選出 Chennai + cosmetics 資料
subset = df[(df['Product type'] == 'cosmetics') & (df['Location'] == 'Chennai')]

print(f"Chennai + cosmetics 總筆數: {len(subset)}")
print(subset.to_string())

# Step 1: 篩選出 Chennai + skincare 資料
subset = df[(df['Product type'] == 'skincare') & (df['Location'] == 'Chennai')]

print(f"Chennai + skincare 總筆數: {len(subset)}")
print(subset.to_string())

"""### 4-5. 每個 Location 中，不同 Product type 的 boxplot"""

sns.boxplot(x='Location', y='Defect rates', hue='Product type', data=df)

"""### 4-6. 加入時間維度：觀察缺陷率是否穩定或趨勢性增加

做不了，因為沒有時間欄位
"""

color_map_trans = {
    'Air': '#FBFFB9',
    'Sea': '#ffc952',
    'Rail': '#47b8e0',
    'Road': '#274c5e'
}

filtered_df = df[(df['Location'] == 'Chennai') & (df['Product type'] == 'haircare')]

# 分組計數
supplier_counts = filtered_df['Supplier name'].value_counts()
transportation_counts = filtered_df['Transportation modes'].value_counts()

# 建立並排的畫布
fig, axes = plt.subplots(1, 2, figsize=(14, 7))

# 左邊：供應商圓餅圖
axes[0].pie(
    supplier_counts,
    labels=supplier_counts.index,
    autopct='%1.1f%%',
    startangle=140
)
axes[0].set_title('Supplier Distribution\n(Haircare Products in Chennai)')
axes[0].axis('equal')

# 右邊：運輸模式圓餅圖
axes[1].pie(
    transportation_counts,
    labels=transportation_counts.index,
    autopct='%1.1f%%',
    startangle=140,
    colors = [color_map_trans.get(mode, '#cccccc') for mode in transportation_counts.index]

)
axes[1].set_title('Transportation Modes\n(Haircare Products in Chennai)')
axes[1].axis('equal')

# 美化排版
plt.tight_layout()
plt.show()

"""## ML

"""

# ❗ 請排除非預測變數欄（例如 SKU, Revenue generated, Defect rates 本身）
features = ['Product type', 'Price', 'Availability',
            'Number of products sold', 'Stock levels', 'Lead times',
            'Order quantities', 'Shipping times', 'Shipping carriers',
            'Shipping costs', 'Supplier name', 'Location',
            'Production volumes', 'Manufacturing lead time',
            'Manufacturing costs', 'Inspection results',
            'Transportation modes', 'Routes', 'Costs']

target = 'Defect rates'

# 🔍 選出模型訓練用資料
X = df[features]
y = df[target]

# 分類與數值欄位分開處理
categorical_cols = X.select_dtypes(include=['object']).columns.tolist()
numeric_cols = X.select_dtypes(include=['int64', 'float64']).columns.tolist()

# One-hot 編碼類別欄位
preprocessor = ColumnTransformer(
    transformers=[
        ('num', 'passthrough', numeric_cols),
        ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_cols)
    ])

# 建立 Pipeline
model = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('regressor', RandomForestRegressor(n_estimators=100, random_state=42))
])

# 分割資料集
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 模型訓練
model.fit(X_train, y_train)

# 預測
y_pred = model.predict(X_test)

# 評估指標
print("MAE:", mean_absolute_error(y_test, y_pred))
print("MSE:", mean_squared_error(y_test, y_pred))
print("R²:", r2_score(y_test, y_pred))

# Create a target variable - High Defect Rate (1 if defect rate > median, else 0)
median_defect = df['Defect rates'].median()
df['High_Defect'] = (df['Defect rates'] > median_defect).astype(int)

# Select features and target
features = ['Price', 'Availability', 'Number of products sold', 'Revenue generated',
           'Stock levels', 'Lead times', 'Order quantities', 'Shipping times',
           'Shipping costs', 'Lead time', 'Production volumes',
           'Manufacturing lead time', 'Manufacturing costs']
target = 'High_Defect'

X = df[features]
y = df[target]

# Split data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42, stratify=y)

# Scale numerical features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""### Random Forest"""

# Initialize and train random forest
rf = RandomForestClassifier(n_estimators=200, max_depth=10,
                          random_state=42, n_jobs=-1)
rf.fit(X_train_scaled, y_train)

# Make predictions
y_pred_rf = rf.predict(X_test_scaled)
y_prob_rf = rf.predict_proba(X_test_scaled)[:, 1]

# Evaluate model
print("Random Forest Performance:")
print(f"Accuracy: {accuracy_score(y_test, y_pred_rf):.4f}")
print(f"ROC AUC: {roc_auc_score(y_test, y_prob_rf):.4f}")
print("\nClassification Report:")
print(classification_report(y_test, y_pred_rf))

# Feature importance
rf_feat_importances = pd.Series(rf.feature_importances_, index=features)
rf_feat_importances.nlargest(10).plot(kind='barh', color='teal')
plt.title('Random Forest Feature Importance')
plt.show()

"""### XGBoost"""

# 指定 features 與 target
features = ['Product type', 'SKU', 'Price', 'Availability',
            'Number of products sold', 'Customer demographics',
            'Stock levels', 'Lead times', 'Order quantities', 'Shipping times',
            'Shipping carriers', 'Shipping costs', 'Supplier name', 'Location',
            'Lead time', 'Production volumes', 'Manufacturing lead time',
            'Manufacturing costs', 'Inspection results', 'Defect rates',
            'Transportation modes', 'Routes', 'Costs']

target = 'Revenue generated'

# 分離特徵與標籤
df_selected = df[features + [target]].copy()

# One-Hot Encoding 類別型欄位
df_encoded = pd.get_dummies(df_selected, drop_first=True)

# 分離 X, y
X = df_encoded.drop(columns=[target])
y = df_encoded[target]

# 資料切分
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 建立 XGBoost 模型並訓練
xgb = XGBRegressor(random_state=42, verbosity=0)
xgb.fit(X_train, y_train)

# 預測評估
r2_score = xgb.score(X_test, y_test)
print(f"XGBoost 測試集 R²: {r2_score:.4f}")

# 特徵重要性視覺化
importances = xgb.feature_importances_
importance_df = pd.DataFrame({
    'Feature': X.columns,
    'Importance': importances
}).sort_values(by='Importance', ascending=False)

# 繪圖
plt.figure(figsize=(10, 10))
sns.barplot(data=importance_df.head(30), x='Importance', y='Feature', palette='magma')  # 顯示前 30 個特徵
plt.title('XGBoost Feature Importance (One-Hot Encoding)')
plt.tight_layout()
plt.show()

#SNAP
import shap
import matplotlib.pyplot as plt

# 1. 匯入你訓練好的模型
from sklearn.ensemble import RandomForestRegressor
model = RandomForestRegressor()
model.fit(X_train, y_train)

# 2. 建立 SHAP Explainer
explainer = shap.Explainer(model, X_train)

# 3. 計算 SHAP 值
shap_values = explainer(X_train)

# 4. 繪製 summary plot（最常用）
shap.summary_plot(shap_values, X_train)

# （選擇性）個別觀測值的解釋
shap.plots.waterfall(shap_values[0])  # 第一筆資料的 SHAP 解釋

#SNAP
from xgboost import XGBRegressor
model_XGB = XGBRegressor()
model_XGB.fit(X_train, y_train)

# 2. 建立 SHAP Explainer
explainer = shap.Explainer(model_XGB, X_train)

# 3. 計算 SHAP 值
shap_values = explainer(X_train)

# 4. 繪製 summary plot（最常用）
shap.summary_plot(shap_values, X_train)

# （選擇性）個別觀測值的解釋
shap.plots.waterfall(shap_values[0])  # 第一筆資料的 SHAP 解釋

# 價格高低與defect rates是否有關
# defect rates到多少算高
# outlier還沒處理
# groupby(product type)的suppliers barplot