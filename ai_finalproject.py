# -*- coding: utf-8 -*-
"""AI_finalProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HOtQfy-1pfYUiPlRxOMsZCujcSxSN88g
"""

from google.colab import drive
drive.mount('/content/drive')

import pickle
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import pearsonr
import scipy.stats as stats
import statsmodels.api as sm
from statsmodels.formula.api import ols
import plotly.express as px

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBRegressor
from sklearn.preprocessing import OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import LabelEncoder

from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, roc_auc_score, classification_report
from scipy.stats import pearsonr
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/supply_chain_data.csv')

df.head()

print(len(df))   #100ç­†è³‡æ–™
df.columns

# ç¢ºèªæ˜¯å¦æœ‰ç¼ºå¤±å€¼
df.isnull().sum()   #no missing value

"""## ç°¡å–®EDA

### Product analysis
"""

color_map_prod = {
    'cosmetics': '#FBFFB9',
    'skincare': '#FDD692',
    'haircare': '#EC7357'
}
# Product type distribution
plt.figure(figsize=(10, 6))
product_counts = df['Product type'].value_counts()
sns.barplot(x = product_counts.index, y = product_counts.values, palette=color_map_prod)
plt.title('Product Type Distribution')
plt.xlabel('Product Type')
plt.ylabel('Count')
plt.show()

# Price distribution by product type
plt.figure(figsize=(12, 6))
sns.boxplot(x='Product type', y='Price', data=df, palette=color_map_prod)
plt.title('Price Distribution by Product Type')
plt.show()

# Revenue vs Products Sold
fig = px.scatter(df, x='Number of products sold', y='Revenue generated',
                 color='Product type', size='Price',
                 title='Revenue vs Products Sold by Product Type')
fig.show()

#defect rate å’Œproduct typeä¹‹é–“çš„é—œä¿‚
plt.figure(figsize=(12, 6))
sns.boxplot(x='Product type', y='Defect rates', data=df, palette=color_map_prod)
plt.title('Defect Rate Distribution by Product Type')
plt.xlabel('Product Type')
plt.ylabel('Defect Rate')
plt.xticks(rotation=45)
plt.show()

# è‡ªè¨‚çš„é¡è‰²å°ç…§è¡¨
color_map_trans = {
    'Air': '#FBFFB9',
    'Sea': '#ffc952',
    'Rail': '#47b8e0',
    'Road': '#274c5e'
}

# åˆ†çµ„
grouped = df.groupby('Product type')

# å­åœ–æ’åˆ—è¨­å®š
n_types = len(grouped)
n_cols = 3
n_rows = (n_types + n_cols - 1) // n_cols
fig, axes = plt.subplots(n_rows, n_cols, figsize=(n_cols * 5, n_rows * 5))
axes = axes.flatten()

# ç¹ªåœ–
for i, (product_type, group) in enumerate(grouped):
    mode_counts = group['Transportation modes'].value_counts()
    modes = mode_counts.index
    sizes = mode_counts.values
    colors = [color_map_trans.get(mode, '#bbbbbb') for mode in modes]  # è‹¥é‡æœªçŸ¥æ¨¡å¼å‰‡ç”¨ç°è‰²

    axes[i].pie(
        sizes,
        labels=modes,
        autopct='%1.1f%%',
        startangle=90,
        colors=colors
    )
    axes[i].set_title(f'{product_type} - Transportation Modes')

# ç§»é™¤å¤šé¤˜å­åœ–
for j in range(i + 1, len(axes)):
    fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""### Location analysis"""

# Location-wise product distribution
location_product = df.groupby(['Location', 'Product type']).size().unstack()
location_product.plot(kind='bar', stacked=True, figsize=(12, 6))
plt.title('Product Distribution by Location')
plt.ylabel('Count')
plt.show()

# Supplier performance metrics
supplier_metrics = df.groupby('Supplier name').agg({
    'Lead times': 'mean',
    'Manufacturing costs': 'mean',
    'Defect rates': 'mean'
}).reset_index()

fig = px.bar(supplier_metrics, x='Supplier name', y=['Lead times', 'Manufacturing costs', 'Defect rates'],
             title='Supplier Performance Metrics', barmode='group')
fig.show()

# ç¹ªè£½ boxplot
plt.figure(figsize=(16, 8))
sns.boxplot(
    data=df,
    x='Location',
    y='Manufacturing costs',
    hue='Product type'
)
plt.title('Manufacturing Costs by Product Type and Location')
plt.xlabel('Location')
plt.ylabel('Manufacturing Costs')
plt.xticks(rotation=45)
plt.legend(title='Location', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

plt.figure(figsize=(16, 8))
sns.boxplot(
    data=df,
    x='Location',
    y='Shipping costs',
    hue='Product type'
)
plt.title('Shipping costs Product Type and Location')
plt.xlabel('Location')
plt.ylabel('Shipping Costs')
plt.xticks(rotation=45)
plt.legend(title='Location', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

plt.figure(figsize=(16, 8))
sns.boxplot(
    data=df,
    x='Location',
    y='Costs',
    hue='Product type'
)
plt.title('Costs Product Type and Location')
plt.xlabel('Location')
plt.ylabel('Costs')
plt.xticks(rotation=45)
plt.legend(title='Location', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

plt.figure(figsize=(16, 8))
sns.boxplot(
    data=df,
    x='Location',
    y='Lead times',
    hue='Product type'
)
plt.title('Lead times by Product Type and Location')
plt.xlabel('Location')
plt.ylabel('Manufacturing Costs')
plt.xticks(rotation=45)
plt.legend(title='Location', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.show()

"""### Transportation and Logistics analysis"""

# Transportation mode analysis
plt.figure(figsize=(10, 6))
sns.countplot(x='Transportation modes', data=df, palette="Blues")
plt.title('Transportation Mode Distribution')
plt.show()

# Shipping costs by carrier
plt.figure(figsize=(12, 6))
sns.boxplot(x='Shipping carriers', y='Shipping costs', hue='Transportation modes', data=df)
plt.title('Shipping Costs by Carrier and Transportation Mode')
plt.show()

# Lead time vs Manufacturing costs
fig = px.scatter(df, x='Lead times', y='Manufacturing costs',
                 color='Product type', size='Production volumes',
                 title='Lead Time vs Manufacturing Costs')
fig.show()

# è¨­å®šé¢¨æ ¼
sns.set(style="whitegrid")

# åœ–ä¸€ï¼šç‰©æµæ–¹å¼ vs. Lead time
plt.figure(figsize=(10, 6))
sns.boxplot(x='Transportation modes', y='Lead time', data=df, palette=color_map_trans)
plt.title('Lead Time by Transportation Mode')
plt.ylabel('Lead Time')
plt.xlabel('Transportation Mode')
plt.show()

# åœ–äºŒï¼šç‰©æµæ–¹å¼ vs. Defect rate
plt.figure(figsize=(10, 6))
sns.boxplot(x='Transportation modes', y='Defect rates', data=df, palette=color_map_trans)
plt.title('Defect Rate by Transportation Mode')
plt.ylabel('Defect Rate')
plt.xlabel('Transportation Mode')
plt.show()

"""## 1.ä¸åŒåœ°å€çš„ç‰©æµæ•ˆç‡æœ‰é¡¯è‘—å·®ç•°å—ï¼Ÿ

"""

# ç•«å‡ºä¸åŒåœ°å€çš„é‹é€æ™‚é–“åˆ†ä½ˆï¼ˆå¯è¦–åŒ–ç”¨ï¼‰
plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x='Location', y='Shipping times')
plt.title('Shipping time in different regions') #ä¸åŒåœ°å€çš„é‹é€æ™‚é–“åˆ†ä½ˆ
plt.xticks(rotation=45)
plt.show()

# åˆ†çµ„å–å‡ºæ¯å€‹åœ°å€çš„é‹é€æ™‚é–“
groups = [group['Shipping times'].values for name, group in df.groupby('Location')]

# åšå–®å› å­è®Šç•°æ•¸åˆ†æï¼ˆANOVAï¼‰
f_stat, p_value = stats.f_oneway(*groups)

# è¼¸å‡ºçµæœ
print(f"ANOVA Få€¼: {f_stat:.2f}")
print(f"p-value: {p_value:.4f}")

if p_value < 0.05:
    print("çµè«–ï¼šä¸åŒåœ°å€ä¹‹é–“çš„ç‰©æµæ•ˆç‡ï¼ˆä»¥é‹é€æ™‚é–“è¡¡é‡ï¼‰å­˜åœ¨é¡¯è‘—å·®ç•°ã€‚")
else:
    print("çµè«–ï¼šä¸åŒåœ°å€ä¹‹é–“çš„ç‰©æµæ•ˆç‡å·®ç•°ä¸é¡¯è‘—ã€‚")

"""## 2.ä¸åŒç”¢å“é¡åˆ¥åœ¨ç‰©æµè¡¨ç¾ä¸Šæ˜¯å¦å­˜åœ¨å·®ç•°ï¼Ÿ

"""

# å¯è¦–åŒ–ï¼šä¸åŒç”¢å“é¡åˆ¥çš„é‹é€æ™‚é–“åˆ†ä½ˆ
plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x=df['Product type'], y=df['Shipping times'])
plt.xticks(rotation=45)
plt.title('Shipping times for different products')   #ä¸åŒç”¢å“é¡åˆ¥çš„é‹é€æ™‚é–“æ¯”è¼ƒ
plt.show()

# åˆ†çµ„å–å‡ºæ¯å€‹ç”¢å“é¡åˆ¥çš„é‹é€æ™‚é–“
groups = [group['Shipping times'].values for name, group in df.groupby('Product type')]

# å–®å› å­ ANOVA åˆ†æ
f_stat, p_value = stats.f_oneway(*groups)

# è¼¸å‡ºçµæœ
print(f"ANOVA Få€¼: {f_stat:.2f}")
print(f"p-value: {p_value:.4f}")

if p_value < 0.05:
    print("çµè«–ï¼šä¸åŒç”¢å“é¡åˆ¥ä¹‹é–“çš„ç‰©æµè¡¨ç¾å­˜åœ¨é¡¯è‘—å·®ç•°ã€‚")
else:
    print("çµè«–ï¼šä¸åŒç”¢å“é¡åˆ¥ä¹‹é–“çš„ç‰©æµè¡¨ç¾å·®ç•°ä¸é¡¯è‘—ã€‚")

"""## 3.ç”¢å“é¡åˆ¥èˆ‡åœ°å€ä¹‹é–“æ˜¯å¦å­˜åœ¨äº¤äº’å½±éŸ¿ï¼Ÿ

"""

# å»ºç«‹å…©å› å­å«äº¤äº’ä½œç”¨çš„ ANOVA æ¨¡å‹
model = ols('Q("Revenue generated") ~ C(Q("Product type")) * C(Location)', data=df).fit()
anova_table = sm.stats.anova_lm(model, typ=2)

print(anova_table)

"""çµè«–ï¼šç”¢å“é¡åˆ¥èˆ‡åœ°å€ä¹‹é–“çš„äº¤äº’å½±éŸ¿ä¸¦ä¸é¡¯è‘—

## 4.æ˜¯å¦æœ‰ç‰©æµç“¶é ¸ï¼ˆå¦‚é«˜ç¼ºé™·ç‡æˆ–é«˜æˆæœ¬ï¼‰é›†ä¸­æ–¼ç‰¹å®šçš„åœ°å€ï¼ç”¢å“çµ„åˆï¼Ÿ
"""

# è¨ˆç®—æ¯å€‹åœ°å€-ç”¢å“çµ„åˆçš„å¹³å‡ç¼ºé™·ç‡èˆ‡ç‰©æµæˆæœ¬
grouped = df.groupby(['Product type', 'Location']).agg({
    'Defect rates': 'mean',
    'Costs': 'mean'
}).reset_index()

# å»ºç«‹ pivot table ä¾› heatmap ä½¿ç”¨
pivot_defect = grouped.pivot(index='Product type', columns='Location', values='Defect rates')
pivot_costs = grouped.pivot(index='Product type', columns='Location', values='Costs')

# ç•«å‡ºç¼ºé™·ç‡ç†±åœ–
plt.figure(figsize=(10, 6))
sns.heatmap(pivot_defect, annot=True, cmap='Reds', fmt=".2f")
plt.title('Avg Defect rate-Product Type Ã— Location')
plt.show()

# ç•«å‡ºæˆæœ¬ç†±åœ–
plt.figure(figsize=(10, 6))
sns.heatmap(pivot_costs, annot=True, cmap='Blues', fmt=".2f")
plt.title('Avg Cost-Product Type Ã— Location')
plt.show()

"""### 4-2.åƒ¹æ ¼é«˜ä½èˆ‡defect ratesæ˜¯å¦æœ‰é—œ"""

# 1. åˆ†ä¸‰åˆ†ä½æ•¸ç­‰åˆ†åƒ¹æ ¼
df['Price_group'] = pd.qcut(df['Price'], q=3, labels=['Low', 'Medium', 'High'])

# 2. ç¹ªè£½ç‘•ç–µç‡çš„ boxplot
plt.figure(figsize=(8, 6))
sns.boxplot(x='Price_group', y='Defect rates', data=df, palette='Set2')
plt.title('Defect Rates by Price Group (Low / Medium / High)')
plt.xlabel('Price Group')
plt.ylabel('Defect Rate')
plt.tight_layout()
plt.show()

corr, p_value = pearsonr(df['Price'], df['Defect rates'])
print(f"Correlation: {corr}, P-value: {p_value}")

"""çµè«–ï¼šåƒ¹æ ¼é«˜ä½èˆ‡defect rateé—œä¿‚ä¸¦ä¸é¡¯è‘—

### 4-3. Product type èˆ‡ Location æ˜¯å¦é¡¯è‘—å½±éŸ¿ç‘•ç–µç‡
è¦‹3.

###4-4. é–å®šç•°å¸¸å€¼ï¼šè¿½æŸ¥ç•°å¸¸é«˜ç‘•ç–µç‡çš„åŸå› 
"""

# Step 1: ç¯©é¸å‡º Chennai + haircare è³‡æ–™
subset = df[(df['Product type'] == 'haircare') & (df['Location'] == 'Chennai')]

print(f"Chennai + haircare ç¸½ç­†æ•¸: {len(subset)}")
display(subset.describe(include='all'))

# Step 2: æª¢è¦–ç›¸é—œæ¬„ä½çš„åˆ†ä½ˆ
cols_to_plot = ['Defect rates', 'Manufacturing lead time', 'Manufacturing costs',
                'Inspection results', 'Price', 'Revenue generated']

for col in cols_to_plot:
    plt.figure(figsize=(6, 4))
    sns.histplot(subset[col], kde=True, bins=10)
    plt.title(f'{col} distribution - haircare@Chennai')
    plt.show()

# Step 3: çœ‹çœ‹æ˜¯å¦æŸäº›ä¾›æ‡‰å•†å°è‡´å“è³ªä¸‹é™
plt.figure(figsize=(12, 6))
sns.boxplot(data=subset, x='Supplier name', y='Defect rates', palette='Set2')

# è¨ˆç®—å„ä¾›æ‡‰å•†å¹³å‡ç‘•ç–µç‡
mean_rates = subset.groupby('Supplier name')['Defect rates'].mean()

# åœ¨æ¯å€‹ box ä¸Šæ–¹æ¨™ç¤ºå¹³å‡å€¼
for i, supplier in enumerate(mean_rates.index):
    mean_val = mean_rates[supplier]
    plt.text(i, mean_val + 0.05, f"{mean_val:.2f}",
             ha='center', va='bottom', fontsize=10, color='black')

plt.title('Chennai haircare - defect rate from different suppliers: Boxplot + mean')
plt.ylabel('Defect Rate')
plt.xlabel('Supplier Name')
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

# Step 4: èˆ‡å…¶ä»–åœ°å€ haircare åšæ¯”è¼ƒ
others = df[(df['Product type'] == 'haircare') & (df['Location'] != 'Chennai')]

compare_cols = ['Defect rates', 'Manufacturing lead time', 'Manufacturing costs', 'Price']

for col in compare_cols:
    plt.figure(figsize=(8, 4))
    sns.boxplot(data=df[df['Product type'] == 'haircare'], x='Location', y=col)
    plt.title(f'{col} - haircare at different location')
    plt.show()

print(subset.to_string())

# Step 1: ç¯©é¸å‡º Chennai + cosmetics è³‡æ–™
subset = df[(df['Product type'] == 'cosmetics') & (df['Location'] == 'Chennai')]

print(f"Chennai + cosmetics ç¸½ç­†æ•¸: {len(subset)}")
print(subset.to_string())

# Step 1: ç¯©é¸å‡º Chennai + skincare è³‡æ–™
subset = df[(df['Product type'] == 'skincare') & (df['Location'] == 'Chennai')]

print(f"Chennai + skincare ç¸½ç­†æ•¸: {len(subset)}")
print(subset.to_string())

"""### 4-5. æ¯å€‹ Location ä¸­ï¼Œä¸åŒ Product type çš„ boxplot"""

sns.boxplot(x='Location', y='Defect rates', hue='Product type', data=df)

"""### 4-6. åŠ å…¥æ™‚é–“ç¶­åº¦ï¼šè§€å¯Ÿç¼ºé™·ç‡æ˜¯å¦ç©©å®šæˆ–è¶¨å‹¢æ€§å¢åŠ 

åšä¸äº†ï¼Œå› ç‚ºæ²’æœ‰æ™‚é–“æ¬„ä½
"""

color_map_trans = {
    'Air': '#FBFFB9',
    'Sea': '#ffc952',
    'Rail': '#47b8e0',
    'Road': '#274c5e'
}

filtered_df = df[(df['Location'] == 'Chennai') & (df['Product type'] == 'haircare')]

# åˆ†çµ„è¨ˆæ•¸
supplier_counts = filtered_df['Supplier name'].value_counts()
transportation_counts = filtered_df['Transportation modes'].value_counts()

# å»ºç«‹ä¸¦æ’çš„ç•«å¸ƒ
fig, axes = plt.subplots(1, 2, figsize=(14, 7))

# å·¦é‚Šï¼šä¾›æ‡‰å•†åœ“é¤…åœ–
axes[0].pie(
    supplier_counts,
    labels=supplier_counts.index,
    autopct='%1.1f%%',
    startangle=140
)
axes[0].set_title('Supplier Distribution\n(Haircare Products in Chennai)')
axes[0].axis('equal')

# å³é‚Šï¼šé‹è¼¸æ¨¡å¼åœ“é¤…åœ–
axes[1].pie(
    transportation_counts,
    labels=transportation_counts.index,
    autopct='%1.1f%%',
    startangle=140,
    colors = [color_map_trans.get(mode, '#cccccc') for mode in transportation_counts.index]

)
axes[1].set_title('Transportation Modes\n(Haircare Products in Chennai)')
axes[1].axis('equal')

# ç¾åŒ–æ’ç‰ˆ
plt.tight_layout()
plt.show()

"""## ML

"""

# â— è«‹æ’é™¤éé æ¸¬è®Šæ•¸æ¬„ï¼ˆä¾‹å¦‚ SKU, Revenue generated, Defect rates æœ¬èº«ï¼‰
features = ['Product type', 'Price', 'Availability',
            'Number of products sold', 'Stock levels', 'Lead times',
            'Order quantities', 'Shipping times', 'Shipping carriers',
            'Shipping costs', 'Supplier name', 'Location',
            'Production volumes', 'Manufacturing lead time',
            'Manufacturing costs', 'Inspection results',
            'Transportation modes', 'Routes', 'Costs']

target = 'Defect rates'

# ğŸ” é¸å‡ºæ¨¡å‹è¨“ç·´ç”¨è³‡æ–™
X = df[features]
y = df[target]

# åˆ†é¡èˆ‡æ•¸å€¼æ¬„ä½åˆ†é–‹è™•ç†
categorical_cols = X.select_dtypes(include=['object']).columns.tolist()
numeric_cols = X.select_dtypes(include=['int64', 'float64']).columns.tolist()

# One-hot ç·¨ç¢¼é¡åˆ¥æ¬„ä½
preprocessor = ColumnTransformer(
    transformers=[
        ('num', 'passthrough', numeric_cols),
        ('cat', OneHotEncoder(handle_unknown='ignore'), categorical_cols)
    ])

# å»ºç«‹ Pipeline
model = Pipeline(steps=[
    ('preprocessor', preprocessor),
    ('regressor', RandomForestRegressor(n_estimators=100, random_state=42))
])

# åˆ†å‰²è³‡æ–™é›†
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# æ¨¡å‹è¨“ç·´
model.fit(X_train, y_train)

# é æ¸¬
y_pred = model.predict(X_test)

# è©•ä¼°æŒ‡æ¨™
print("MAE:", mean_absolute_error(y_test, y_pred))
print("MSE:", mean_squared_error(y_test, y_pred))
print("RÂ²:", r2_score(y_test, y_pred))

# Create a target variable - High Defect Rate (1 if defect rate > median, else 0)
median_defect = df['Defect rates'].median()
df['High_Defect'] = (df['Defect rates'] > median_defect).astype(int)

# Select features and target
features = ['Price', 'Availability', 'Number of products sold', 'Revenue generated',
           'Stock levels', 'Lead times', 'Order quantities', 'Shipping times',
           'Shipping costs', 'Lead time', 'Production volumes',
           'Manufacturing lead time', 'Manufacturing costs']
target = 'High_Defect'

X = df[features]
y = df[target]

# Split data into train and test sets
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.3, random_state=42, stratify=y)

# Scale numerical features
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""### Random Forest"""

# Initialize and train random forest
rf = RandomForestClassifier(n_estimators=200, max_depth=10,
                          random_state=42, n_jobs=-1)
rf.fit(X_train_scaled, y_train)

# Make predictions
y_pred_rf = rf.predict(X_test_scaled)
y_prob_rf = rf.predict_proba(X_test_scaled)[:, 1]

# Evaluate model
print("Random Forest Performance:")
print(f"Accuracy: {accuracy_score(y_test, y_pred_rf):.4f}")
print(f"ROC AUC: {roc_auc_score(y_test, y_prob_rf):.4f}")
print("\nClassification Report:")
print(classification_report(y_test, y_pred_rf))

# Feature importance
rf_feat_importances = pd.Series(rf.feature_importances_, index=features)
rf_feat_importances.nlargest(10).plot(kind='barh', color='teal')
plt.title('Random Forest Feature Importance')
plt.show()

"""### XGBoost"""

# æŒ‡å®š features èˆ‡ target
features = ['Product type', 'SKU', 'Price', 'Availability',
            'Number of products sold', 'Customer demographics',
            'Stock levels', 'Lead times', 'Order quantities', 'Shipping times',
            'Shipping carriers', 'Shipping costs', 'Supplier name', 'Location',
            'Lead time', 'Production volumes', 'Manufacturing lead time',
            'Manufacturing costs', 'Inspection results', 'Defect rates',
            'Transportation modes', 'Routes', 'Costs']

target = 'Revenue generated'

# åˆ†é›¢ç‰¹å¾µèˆ‡æ¨™ç±¤
df_selected = df[features + [target]].copy()

# One-Hot Encoding é¡åˆ¥å‹æ¬„ä½
df_encoded = pd.get_dummies(df_selected, drop_first=True)

# åˆ†é›¢ X, y
X = df_encoded.drop(columns=[target])
y = df_encoded[target]

# è³‡æ–™åˆ‡åˆ†
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# å»ºç«‹ XGBoost æ¨¡å‹ä¸¦è¨“ç·´
xgb = XGBRegressor(random_state=42, verbosity=0)
xgb.fit(X_train, y_train)

# é æ¸¬è©•ä¼°
r2_score = xgb.score(X_test, y_test)
print(f"XGBoost æ¸¬è©¦é›† RÂ²: {r2_score:.4f}")

# ç‰¹å¾µé‡è¦æ€§è¦–è¦ºåŒ–
importances = xgb.feature_importances_
importance_df = pd.DataFrame({
    'Feature': X.columns,
    'Importance': importances
}).sort_values(by='Importance', ascending=False)

# ç¹ªåœ–
plt.figure(figsize=(10, 10))
sns.barplot(data=importance_df.head(30), x='Importance', y='Feature', palette='magma')  # é¡¯ç¤ºå‰ 30 å€‹ç‰¹å¾µ
plt.title('XGBoost Feature Importance (One-Hot Encoding)')
plt.tight_layout()
plt.show()

#SNAP
import shap
import matplotlib.pyplot as plt

# 1. åŒ¯å…¥ä½ è¨“ç·´å¥½çš„æ¨¡å‹
from sklearn.ensemble import RandomForestRegressor
model = RandomForestRegressor()
model.fit(X_train, y_train)

# 2. å»ºç«‹ SHAP Explainer
explainer = shap.Explainer(model, X_train)

# 3. è¨ˆç®— SHAP å€¼
shap_values = explainer(X_train)

# 4. ç¹ªè£½ summary plotï¼ˆæœ€å¸¸ç”¨ï¼‰
shap.summary_plot(shap_values, X_train)

# ï¼ˆé¸æ“‡æ€§ï¼‰å€‹åˆ¥è§€æ¸¬å€¼çš„è§£é‡‹
shap.plots.waterfall(shap_values[0])  # ç¬¬ä¸€ç­†è³‡æ–™çš„ SHAP è§£é‡‹

#SNAP
from xgboost import XGBRegressor
model_XGB = XGBRegressor()
model_XGB.fit(X_train, y_train)

# 2. å»ºç«‹ SHAP Explainer
explainer = shap.Explainer(model_XGB, X_train)

# 3. è¨ˆç®— SHAP å€¼
shap_values = explainer(X_train)

# 4. ç¹ªè£½ summary plotï¼ˆæœ€å¸¸ç”¨ï¼‰
shap.summary_plot(shap_values, X_train)

# ï¼ˆé¸æ“‡æ€§ï¼‰å€‹åˆ¥è§€æ¸¬å€¼çš„è§£é‡‹
shap.plots.waterfall(shap_values[0])  # ç¬¬ä¸€ç­†è³‡æ–™çš„ SHAP è§£é‡‹

# åƒ¹æ ¼é«˜ä½èˆ‡defect ratesæ˜¯å¦æœ‰é—œ
# defect ratesåˆ°å¤šå°‘ç®—é«˜
# outlieré‚„æ²’è™•ç†
# groupby(product type)çš„suppliers barplot